#!/bin/bash
# src/check_os.sh
set -o allexport

# shellcheck disable=SC2034
_OS="Unknown"

if [[ "$(uname)" == "Linux" ]]; then
  _OS="Linux"
elif [[ "$(uname)" == "Darwin" ]]; then
  _OS="OSX"
elif [[ $(uname) == *"MINGW"* ]]; then
  _OS="Windows"
fi

# src/colors.sh
set -o allexport

export COLOR_RED="\033[1;31m"
export COLOR_GREEN="\033[1;32m"
export COLOR_YELLOW="\033[1;33m"
export COLOR_BLUE="\033[1;34m"
export COLOR_PURPLE="\033[1;35m"
export COLOR_CYAN="\033[1;36m"
export COLOR_ORANGE="\033[38;5;214m"
export COLOR_RESET="\033[0m"

# src/compare.sh
set -euo pipefail

# shellcheck disable=SC2005

function compare::source_with_target() {
  local source=$1
  local target=$2

  echo -e "Comparing ${COLOR_ORANGE}$source${COLOR_RESET} with ${COLOR_ORANGE}$target${COLOR_RESET}"
  echo -e "${COLOR_BLUE}------------------------------------------------------------------${COLOR_RESET}"
  echo -e "Commits to include in the release (into ${COLOR_ORANGE}$target${COLOR_RESET}):"
  echo "$(git log --color --oneline origin/"$target".."$source")"
  echo -e "${COLOR_BLUE}------------------------------------------------------------------${COLOR_RESET}"
  echo -e "Changed files between '${COLOR_ORANGE}$target${COLOR_RESET}' and '${COLOR_ORANGE}$source${COLOR_RESET}':"
  compare::render_changed_files "$source" "$target"
}

function compare::render_changed_files() {
  local source=$1
  local target=$2

  local added_files=()
  local modified_files=()
  local deleted_files=()

  # Collect files based on their status
  while read -r status file; do
      case "$status" in
          A) # Added (created)
              added_files+=("$file")
              ;;
          M) # Modified (updated)
              modified_files+=("$file")
              ;;
          D) # Deleted
              deleted_files+=("$file")
              ;;
      esac
  done < <(git diff --name-status "$target".."$source")

  # Output the files, sorted by status

  # Added (created) files
  if [ "${#added_files[@]}" -gt 0 ]; then
    for file in "${added_files[@]}"; do
        echo -e "${COLOR_GREEN}+ $file${COLOR_RESET}"
    done
  fi

  # Modified (updated) files
  if [ "${#modified_files[@]}" -gt 0 ]; then
    for file in "${modified_files[@]}"; do
        echo -e "${COLOR_YELLOW}~ $file${COLOR_RESET}"
    done
  fi


  # Deleted files
  if [ "${#deleted_files[@]}" -gt 0 ]; then
    for file in "${deleted_files[@]}"; do
        echo -e "${COLOR_RED}- $file${COLOR_RESET}"
    done
  fi
}

# src/console_header.sh
set -o allexport

function console_header::print_version() {
  printf "%s\n" "$(cat "$(dirname "${BASH_SOURCE[0]}")"/version.txt)"
}

function console_header::print_help() {
  cat <<EOL
Usage: deploy [arguments] [options]

Arguments:
  source-branch        The branch name to deploy.
  target-branch        The target branch to deploy to (optional, default: prod).
  development-branch   The development branch (optional, default: main).

Options:
  --debug              Enable debug mode (set -x).
  --dry-run            Simulate the deployment process without making any changes.
  --force              Ignore that your current local branch has ahead commits.
  -s, --source         Specify the source branch.
  -t, --target         Specify the target branch.
  -d, --development    Specify the development branch.

Examples:
  deploy main
  deploy main --dry-run
  deploy fix/... --force
  deploy fix/... --dry-run --force
EOL
}

# src/env_configuration.sh

# shellcheck source=/dev/null
[[ -f ".env" ]] && source .env set
set +o allexport

# src/io.sh
set -euo pipefail

# shellcheck disable=SC2155
function io::confirm_or_exit() {
  local txt=$(echo -e "$1 (Y/n):")
  read -p "$txt " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]
  then
    exit 1
  fi
}

# src/main.sh
set -euo pipefail

# shellcheck disable=SC2155
function main::action() {
  local source=${1:-main}
  local target=${2:-prod}
  local development=${3:-1:-}
  local force_deploy=${4:-false}

  main::render_steps "$source" "$target" "$development"

  echo -e "${COLOR_PURPLE}------------------------------------------------------------------${COLOR_RESET}"
  git fetch origin
  git status
  echo -e "${COLOR_BLUE}------------------------------------------------------------------${COLOR_RESET}"

  echo -e "Using source branch: ${COLOR_ORANGE}$source${COLOR_RESET}"
  validate::no_diff_between_local_and_origin "$source" "$target" "$force_deploy"

  local changed_files=$(git diff --name-only "$target".."$source")
  local latest_tag=$(git describe --tags "$(git rev-list --tags --max-count=1)" 2>/dev/null || echo "v0")

  echo -e "Current latest tag: ${COLOR_CYAN}$latest_tag${COLOR_RESET}"
  local new_tag=$(release::generate_new_tag "$latest_tag" "$changed_files")
  compare::source_with_target "$source" "$target"

  # shellcheck disable=SC2116
  local question=$(echo "Force checkout ${COLOR_ORANGE}origin/$target${COLOR_RESET}" \
    "and create new tag ${COLOR_CYAN}$new_tag${COLOR_RESET}... Ready to start?")
  io::confirm_or_exit "$question"

  if [ -z "$changed_files" ]; then
    echo -e "${COLOR_YELLOW}No files changed between branches, skipping merge.${COLOR_RESET}"
    exit 0
  fi

  main::force_checkout "$target"
  main::merge_source_to_target "$source" "$target"

  release::create_tag "$new_tag" "$changed_files"
  release::create_github_release "$latest_tag" "$new_tag"

  main::update_development "$development" "$target"
}

function main::render_steps() {
  local source=$1
  local target=$1
  local development=$2

  echo "This script will automate the release process and follow the following steps:"
  echo "- Define the branch to deploy: $source"
  echo "- Fetch latest remote changes"
  echo "- Compare the branch with $target to view the commits that will be deployed"
  echo "- Confirm you wish to proceed"
  echo "- Merge the selected branch to $target"
  echo "- Create a tag and release"
  echo "- Merge the selected branch back to $development"
  echo ""
  echo "This script must use your local git environment."
}

function main::update_development() {
  local development=$1
  local target=$2

  echo -e "Merging ${COLOR_ORANGE}$target${COLOR_RESET} back to" \
    "${COLOR_ORANGE}$development${COLOR_RESET} (increase the release contains hotfixes" \
    "that are not in ${COLOR_ORANGE}$development${COLOR_RESET})"

  main::force_checkout "$development"
  main::merge_source_to_target "remotes/origin/$target" "$development"
}

function main::merge_source_to_target() {
  local source=$1
  local target=$2

  echo -e "Merging ${COLOR_ORANGE}$source${COLOR_RESET} release to ${COLOR_ORANGE}$target${COLOR_RESET}"

  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${COLOR_CYAN}--dry-run enabled. Skipping git merge ($source into $target)${COLOR_RESET}"
    return
  fi

  if ! git merge "$source"; then
    echo -e "${COLOR_RED}Merge failed. Please resolve conflicts and try again.${COLOR_RESET}"
    exit 1
  fi

  git push origin "$target" --no-verify

}

function main::force_checkout() {
  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${COLOR_CYAN}--dry-run enabled. Skipping git checkout${COLOR_RESET}"
    return
  fi

  git config advice.detachedHead false
  [ -f .git/hooks/post-checkout ] && mv .git/hooks/post-checkout .git/hooks/post-checkout.bak
  git checkout -f origin/"$1"
  git branch -D "$1"
  git checkout -b "$1" origin/"$1"
  [ -f .git/hooks/post-checkout.bak ] && mv .git/hooks/post-checkout.bak .git/hooks/post-checkout
  git config advice.detachedHead true
}

# src/release.sh
set -euo pipefail

function release::generate_new_tag() {
  local latest_tag=$1
  local changed_files=$2

  local tag_number
  if [[ $latest_tag =~ ^v([0-9]+)$ ]]; then
    tag_number="${BASH_REMATCH[1]}"
    tag_number=$((tag_number + 1))
  else
    tag_number=1
  fi

  echo "v$tag_number"
}

function release::create_tag() {
  local new_tag=$1
  local changed_files=$2

  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${COLOR_CYAN}--dry-run enabled. Skipping creating a tag ($new_tag)${COLOR_RESET}"
    return
  fi

  git tag -a "$new_tag" -m "Release $new_tag

Changes:
$changed_files"

  git push origin --tags --no-verify
}

# shellcheck disable=SC2155
function release::create_github_release() {
  if [ "$GH_CLI_INSTALLED" = false ]; then
    return
  fi

  local previous_tag=$1
  local new_tag=$2

  if [ "$previous_tag" = "v0" ]; then
    previous_tag="main"
  fi

  local release_name=$(release::generate_release_name)
  local remote_url=$(git remote get-url origin)
  local repo_info=$(echo "$remote_url" | sed -E 's|git@github\.com:||; s|\.git$||')

  local changelog_url="https://github.com/$repo_info/compare/$previous_tag...$new_tag"
  local full_changelog="**Full Changelog**: $changelog_url"

  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${COLOR_CYAN}--dry-run enabled. Skipping creating a release ($release_name)${COLOR_RESET}"
    return
  fi

  local commits=$(git log --oneline "$previous_tag".."$new_tag")

  gh release create "$new_tag" \
    --title "$release_name" \
    --notes "$(echo -e "$commits\n\n$full_changelog")"
}

# shellcheck disable=SC2155
function release::generate_release_name() {
  local current_date=$(date +"%Y-%m-%d")
  # Use xargs to trim leading/trailing whitespace
  local latest_release=$(gh release list | head -n 1 | awk -F 'Latest' '{print $1}' | xargs)

  local release_number
  if [[ "$latest_release" =~ ^$current_date\ #([0-9]+)$ ]]; then
    release_number=$((BASH_REMATCH[1] + 1))
  else
    release_number=1
  fi

  echo "$current_date #$release_number"
}

# src/validate.sh
set -euo pipefail

function validate::no_diff_between_local_and_origin() {
  local source=$1
  local target=$2
  local force_deploy=$3

  # Check the status of the local branch compared to origin/main
  ahead_commits=$(git rev-list --count HEAD ^origin/main)

  if [[ "$ahead_commits" -gt 0 && "$force_deploy" == false ]]; then
    echo -e "${COLOR_RED}Error: Your $source is ahead of 'origin/$source'" \
      "by $ahead_commits commit(s)${COLOR_RESET}."

    echo -e "${COLOR_YELLOW}Please push your changes or reset \
your${COLOR_RESET} ${COLOR_ORANGE}$source${COLOR_RESET}."

    exit 1
  fi

  if [[ "$ahead_commits" -gt 0 && "$force_deploy" == true ]]; then
    echo -e "Your local ${COLOR_ORANGE}$source${COLOR_RESET} is ahead" \
      "of ${COLOR_ORANGE}origin/$source${COLOR_RESET}" \
      "by ${COLOR_RED}$ahead_commits${COLOR_RESET} commit(s)${COLOR_RESET}."

    # shellcheck disable=SC2155
    # shellcheck disable=SC2116
    local question=$(echo "${COLOR_YELLOW}Are you sure you want to push them" \
      "to 'origin/$target' as part of the release?${COLOR_RESET}")

    io::confirm_or_exit "$question"
  fi
}

#!/bin/bash
set -euo pipefail

DEPLOY_ROOT_DIR="$(dirname "${BASH_SOURCE[0]}")"
export DEPLOY_ROOT_DIR


# Check if at least one argument (branch name) is passed
if [ $# -lt 1 ]; then
  console_header::print_help
  exit 1
fi

FORCE_DEPLOY=false
SOURCE_BRANCH=${SOURCE_BRANCH:-"main"}
TARGET_BRANCH=${TARGET_BRANCH:-"prod"}
DEVELOPMENT_BRANCH=${DEVELOPMENT_BRANCH:-"main"}
DEPLOY_SUCCESSFUL_TEXT=${DEPLOY_SUCCESSFUL_TEXT:-}
DRY_RUN=${DRY_RUN:-false}

while [[ $# -gt 0 ]]; do
  argument="$1"
  case $argument in
    --debug)
      set -x
      ;;
    --dry-run)
      DRY_RUN=true
      ;;
    --help)
      console_header::print_help
      exit 0
      ;;
    -v|--version)
      console_header::print_version
      exit 0
      ;;
    -s|--source)
      SOURCE_BRANCH="$2"
      shift
      ;;
    -t|--target)
      TARGET_BRANCH="$2"
      shift
      ;;
    -d|--development)
      DEVELOPMENT_BRANCH="$2"
      shift
      ;;
    --force)
      FORCE_DEPLOY=true
      ;;
  esac
  shift
done

GH_CLI_INSTALLED=false
if command -v gh &> /dev/null; then
    GH_CLI_INSTALLED=true
fi

export GH_CLI_INSTALLED
export DRY_RUN


main::action "$SOURCE_BRANCH" \
  "$TARGET_BRANCH" \
  "$DEVELOPMENT_BRANCH" \
  "$FORCE_DEPLOY"

echo -e "${COLOR_GREEN}Script completed${COLOR_RESET}"
if [ -n "$DEPLOY_SUCCESSFUL_TEXT" ]; then
  echo -e "$DEPLOY_SUCCESSFUL_TEXT"
fi
